// Rem Attribute VBA_ModuleType=VBAModule
// Option VBASupport 1
// TODO refactor into class
import {
  BirdCollisionConfigType,
  IntegralAreaCollisionConfig,
  WindfarmCollisionConfigType,
} from "./types";

export function pcoll(
  r: number,
  phi: number,
  updown: "up" | "down",
  windfarm: WindfarmCollisionConfigType,
  bird: BirdCollisionConfigType
): {
  pcollision: number;
  alpha?: number;
  colllength?: number;
} {
  //
  // 'this function evaluates the collision risk at r,phi for up or downwind flight
  // ' r is dimensionless (r/R) and phi in degrees
  // 'assuming flight perpendicular to rotors
  // 'it calls a linear interpolation function to evaluate the chord width at radius r

  // Application.Volatile
  // Application.Calculation = xlCalculationAutomatic
  let result: {
    pcollision: number;
    alpha?: number;
    colllength?: number;
  } = { pcollision: 1 };
  let { blades, radius, pitch, chord, omega, bladeForm } = windfarm;

  let { speed, wingspan, length, flight_type } = bird;

  let multiplier; // As Single
  let direction = updown === "up" ? 1 : -1; // :number

  const pi = Math.PI;
  phi = (phi * pi) / 180; //'converts degrees to radians

  radius = radius * r; //'converts r to real radius
  chord = chord * interpolate(bladeForm, r); //'interpolates from c/C data for this r
  omega = (omega * 2 * pi) / 60; //             'converts rpm to radians/sec
  pitch = (pitch * pi) / 180; //           'converts degrees to radians

  if (flight_type === "flapping") {
  } else {
    if (flight_type === "gliding") {
      wingspan = wingspan * Math.abs(Math.cos(phi));
    }
  }

  multiplier = (blades * omega) / (2 * pi * speed);

  if (radius === 0) {
    result.pcollision = 1;
  } else {
    const alpha = speed / (radius * omega);
    result.alpha = alpha;
    const collidelength =
      Math.abs(
        direction * chord * Math.sin(pitch) + alpha * chord * Math.cos(pitch)
      ) + Math.max(length, wingspan * alpha);

    result.colllength = collidelength;
    result.pcollision = Math.min(1, multiplier * collidelength);
  }
  return result;
}

export function interpolate(A: [number, number][], y: number): number {
  // ' this function uses the input value y
  // ' a set of points in range A and corresponding data in range B, both ranges length N
  // ' identifies the pair of points bracketing y in range A first column
  // ' then linearly interpolates to produce a data value appropriate to y from the corresponding second column
  // ' error message if y is less than first point or greater than last point
  // ' assumes that set of points in the first column is increasing

  // Application.Volatile
  // Application.Calculation = xlCalculationAutomatic
  let N = A.length - 1;
  let i: number = 0;
  let p: number;
  let ybottom: number;
  let ytop: number;
  let lower: number;
  let upper: number = A[i + 1][0];

  let result = 0;
  ybottom = A[1][0];
  ytop = A[N][0];
  // 'MsgBox ybottom, 0, "ybottom"
  // 'MsgBox ytop, 0, "ytop"
  // 'If (Y < ybottom Or Y > ytop) Then
  // '    MsgBox Y, vbInformation, "outwith data range" + A
  // 'End If
  do {
    lower = A[i][0];
    upper = A[i + 1][0];
    i++;
  } while (upper < y && i < N);

  p = (y - lower) / (upper - lower);
  result = A[i - 1][1] + p * (A[i][1] - A[i - 1][1]);
  return result;
}
export function pcoll_rav(
  rad: number,
  _updown: "up" | "down",
  windfarmConfig: WindfarmCollisionConfigType,
  birdConfig: BirdCollisionConfigType
): number {
  // ' integrates around the annulus at radius r/R
  let total: number = 0;
  let increment: number = 10;
  let updown = _updown;

  if (updown !== "up" && updown !== "down") {
    updown = "up";
  }

  for (let angle = 0; angle <= 180 - increment; angle += increment) {
    total =
      total + pcoll(rad, angle, updown, windfarmConfig, birdConfig).pcollision;
  }

  // 'MsgBox angle, vbInformation, "angle"
  // 'MsgBox total, vbInformation, "total"

  return (total * increment) / 180;
}

export function pcollxy(
  x: number,
  y: number,
  updown: "up" | "down",
  windfarmConfig: WindfarmCollisionConfigType,
  birdConfig: BirdCollisionConfigType
): number {
  let r: number;
  let phi: number;
  let pi: number;

  // 'MsgBox x, vbInformation, "x"
  // 'MsgBox y, vbInformation, "y"

  pi = Math.PI;
  r = Math.sqrt(x * x + y * y);

  if (y === 0) {
    if (x >= 0) {
      phi = pi / 2;
    } else {
      phi = -pi / 2;
    }
  } else {
    phi = Math.atan(x / y);
    if (y < 0) {
      phi = pi + phi;
    }
  }

  phi = (phi * 180) / pi;

  // 'MsgBox r, vbInformation, "r"
  // 'MsgBox phi, vbInformation, "phi"

  return pcoll(r, phi, updown, windfarmConfig, birdConfig).pcollision;
}

export function xareasum2(y: number): number {
  // 'Gives length of chord at y
  if (y > 1 || y < -1) {
    return 0;
  } else {
    return 2 * Math.sqrt(1 - y * y);
  }
}
//
//
export function xrisksum2(
  y: number,
  xinc: number,
  updown: "up" | "down",
  windfarmConfig: WindfarmCollisionConfigType,
  birdConfig: BirdCollisionConfigType
): number {
  let xmax: number;
  let imax: number;
  let i: number;
  let risk: number;
  // 'Integrates x-symmetrical function pcollxy across chord of circle

  if (y > 1 || y < -1) {
    // MsgBox y, vbInformation, "xrisksum2: y outwith bounds of circle"
    return 0;
  } else {
    xmax = Math.sqrt(1 - y * y);
    imax = Math.ceil(xmax / xinc);
    risk =
      (pcollxy(imax * xinc, y, updown, windfarmConfig, birdConfig) / 2 +
        pcollxy(xmax, y, updown, windfarmConfig, birdConfig) / 2) *
      (xmax - imax * xinc);

    if (imax > 0) {
      risk =
        risk +
        (pcollxy(0, y, updown, windfarmConfig, birdConfig) / 2 +
          pcollxy(imax * xinc, y, updown, windfarmConfig, birdConfig) / 2) *
          xinc;
      i = 1;
      do {
        risk =
          risk +
          pcollxy(i * xinc, y, updown, windfarmConfig, birdConfig) * xinc;
        i = i + 1;
      } while (i < imax);
    }

    return 2 * risk;
  }
}

export function ydistsum(
  xinc: number,
  yinc: number,
  updown: "up" | "down",
  configs: IntegralAreaCollisionConfig,
  flag: number
): number {
  // ' This is a trapezoidal integration of bird density x risk across all values of height y
  // '  Height is divided into (2 imax + 1) bands, the lowest being y=-1, the highest y=+1
  // '  Height is converted to metres above sea level then used to find bird density at that level

  // Application.Volatile
  // Application.Calculation = xlCalculationAutomatic

  let i: number;
  let imax: number;
  let total: number = 0;
  let y: number;
  let dy: number;

  let {
    windfarmInstanceConfig: { hubheight, offset },
    flightheights,
    windfarmConfig,
    birdConfig,
  } = configs;
  const { radius } = windfarmConfig;

  imax = Math.ceil(1 / yinc);
  // 'MsgBox imax, vbInformation, "imax"
  // 'MsgBox yinc, vbInformation, "yinc"
  //
  // 'Find bird density at lowest rotor point then calculate risk
  dy = radius * interpolate(flightheights, -1 * radius + hubheight + offset);
  if (flag === 1) {
    total = (dy * xareasum2(-1)) / 2;
  } else {
    total = (dy * xrisksum2(-1, xinc, updown, windfarmConfig, birdConfig)) / 2;
  }

  // 'Find bird density at highest rotor point, then add in risk
  dy = radius * interpolate(flightheights, radius + hubheight + offset);
  if (flag === 1) {
    total = total + (dy * xareasum2(1)) / 2;
  } else {
    total =
      total +
      (dy * xrisksum2(imax * yinc, xinc, updown, windfarmConfig, birdConfig)) /
        2;
  }

  i = -imax + 1;
  while (i < imax) {
    dy =
      radius *
      interpolate(flightheights, i * yinc * radius + hubheight + offset);
    if (flag === 1) {
      total = total + dy * xareasum2(i * yinc);
    } else {
      total =
        total +
        dy * xrisksum2(i * yinc, xinc, updown, windfarmConfig, birdConfig);
    }
    i = i + 1;
  }

  return total * yinc;
}

// 'function ydistdiscretesum(ByVal xinc As Single, updown As String, flag :number) As Single
//
// ' This is a trapezoidal integration of bird density x risk across all values of height y
// '  Height is divided into (2 imax + 1) bands, the lowest being y=-1, the highest y=+1
// '  Height is converted to metres above sea level then used to find bird density at that level
//
// 'Application.Volatile
// 'Application.Calculation = xlCalculationAutomatic
//
// 'let i :number
// 'let imin :number
// 'let imax :number
// 'let total As Single
// 'let npoints :number
// 'let y As Single
// 'let radius As Single
// 'let hubheight As Single
// 'let offset As Single
// 'let dy As Single
// 'let prop As Single
// 'radius = Range("radius").Value
// 'hubheight = Range("hubheight").Value
// 'offset = Range("offset").Value
// 'npoints = Range("npoints").Value
//
// 'total = 0
//
// 'imin = Int(hubheight + offset - radius + 0.5)
// 'imax = Int(hubheight + offset + radius + 0.5)
//
// 'MsgBox imin, vbInformation, "imin"
// 'MsgBox imax, vbInformation, "imax"
//
// '  remember (i+1)'th cell in range is for i metres ie i-0.5 metres to i+0.5 metres
//
// 'Find bird density at lowest rotor point then calculate risk
// '    dy = Range("flightheightdata").Cells(imin + 1, 2)
// '    prop = (imin + 0.5) - (hubheight + offset - radius)
// '   MsgBox imin, vbInformation, "imin"
// '   MsgBox prop, vbInformation, "propmin"
// '    If (flag = 1) Then
// '   MsgBox (imin - hubheight - offset) / radius, vbInformation, "arg"
// '       total = dy * prop * xareasum2((imin - hubheight - offset) / radius)
// '
// '   Else
// '        total = dy * prop * xrisksum2((imin - hubheight - offset) / radius, xinc, updown)
// '    End If
//
// '   MsgBox imax, vbInformation, "imax"
// 'Find bird density at highest rotor point, then add in risk
// '    dy = Range("flightheightdata").Cells(imax + 1, 2)
// '   prop = hubheight + offset + radius - (imax - 0.5)
// '   MsgBox prop, vbInformation, "propmax"
// '    If (flag = 1) Then
// '        total = total + dy * prop * xareasum2((imax - hubheight - offset) / radius)
// '    Else
// '        total = total + dy * prop * xrisksum2((imax - hubheight - offset) / radius, xinc, updown)
// '    End If
// '
// 'i = imin + 1
// '    Do While (i < imax)
// 'MsgBox i, vbInformation, "i"
// '    Find bird density at successive steps in height then add in risk
//
// '    dy = Range("flightheightdata").Cells(i + 1, 2)
// 'MsgBox dy, vbInformation, dy
// '       If (flag = 1) Then
// '            total = total + dy * xareasum2((i - hubheight - offset) / radius)
// '        Else
// '            total = total + dy * xrisksum2((i - hubheight - offset) / radius, xinc, updown)
// '        End If
// '            i = i + 1
// '
// 'ydistdiscretesum = total
// 'End function
//
//
//
